
### ðŸ”§ Replit Prompt (Seal + Walrus + Sui + CV Vault)

> Build a full-stack web app called **â€œOn-Chain CV Proof Vaultâ€** that uses **Sui + Seal** for encryption / access control and **Walrus** (or mocked storage) for blob storage.
>
> ## High-Level Goal
>
> The app should let a candidate:
>
> 1. Upload their **CV as a PDF**
> 2. Encrypt the CV using **Seal** (or mock Seal in a clean way if the SDK is not available)
> 3. Store the **encrypted CV** as a blob in **Walrus** (or a mocked storage adapter)
> 4. Create an **on-chain proof object on Sui** that links:
>
>    * `sealObjectId` (Seal policy object id)
>    * `walrusContentId` or `storageUrl`
>    * `ciphertextHash`
>    * `owner` (candidate wallet address)
>    * `createdAt`
> 5. Get a **shareable verification link** like:
>
>    * `https://cvproof.app/p/<proofCode>`
>
> A recruiter should be able to:
>
> 1. Open the share link
> 2. Connect a Sui wallet (or mock identity)
> 3. Request a decryption key via **Seal** according to the policy
> 4. Download + decrypt the encrypted CV and view it in the browser.
>
> The first version can mock Seal / Walrus / Sui calls, but the code must be structured so that real SDK calls can be plugged in later with minimal changes.
>
> ---
>
> ## Architecture
>
> * Use **Node.js + Express** for the backend.
> * Use **React** for the frontend (e.g. Vite or CRA) in a `/client` folder.
> * Use environment variables (`.env`) for RPC URLs, API keys, etc.
> * Create clear service modules:
>
>   * `server/services/sealService.ts`
>   * `server/services/walrusService.ts`
>   * `server/services/suiService.ts`
>   * `server/services/proofService.ts`
>
> Each of these services should expose clean async functions so that I can later replace the mock logic with real SDK integration.
>
> If you cannot import real SDKs for Seal / Walrus / Sui in Replit, then:
>
> * Implement **mock functions** with the same signatures:
>
>   * `sealService.encryptCV({ pdfBytes, ownerAddress, policy })`
>     â†’ returns `{ ciphertext, sealObjectId }`
>   * `sealService.getDecryptionKey({ sealObjectId, viewerAddress })`
>     â†’ returns `{ decryptKey }` (mocked)
>   * `sealService.decryptCV({ ciphertext, decryptKey })`
>     â†’ returns original `pdfBytes`
>   * `walrusService.uploadEncryptedCV(ciphertext)`
>     â†’ returns `{ walrusContentId, storageUrl }`
>   * `walrusService.fetchEncryptedCV(walrusContentId)`
>     â†’ returns `ciphertext`
>   * `suiService.createCVProof({ ownerAddress, sealObjectId, walrusContentId, ciphertextHash })`
>     â†’ returns `{ txHash, proofCode }`
>   * `suiService.getProofByCode(proofCode)`
>     â†’ returns proof metadata record
>
> Also implement a simple data layer (in-memory or SQLite/JSON) in `proofService` to store:
>
> * `proofCode`
> * `ownerAddress`
> * `sealObjectId`
> * `walrusContentId`
> * `storageUrl`
> * `ciphertextHash`
> * `txHash`
> * `createdAt`
>
> Please add clear comments where real Seal / Walrus / Sui SDK calls should be placed.
>
> ---
>
> ## Core Flows
>
> ### 1. â€œRegister CVâ€ (Candidate)
>
> Route: `/register`
>
> Frontend:
>
> * Form fields:
>
>   * CV upload (PDF only)
>   * Wallet address (string for now, no full wallet connect required)
> * On submit:
>
>   1. Read the PDF as `ArrayBuffer` in the browser.
>   2. Call backend `POST /api/register` with `pdfBytes` and `walletAddress`.
>
> Backend `POST /api/register`:
>
> 1. Use `sealService.encryptCV` to simulate / perform encryption and create a **Seal policy**:
>
>    * Policy concept:
>
>      * `owner = walletAddress`
>      * for now, allow any viewer to decrypt (or hard-code a mocked recruiter address).
> 2. Compute `ciphertextHash` (e.g. SHA-256 of encrypted bytes).
> 3. Call `walrusService.uploadEncryptedCV(ciphertext)` to get `walrusContentId` + `storageUrl`.
> 4. Call `suiService.createCVProof(...)` to get `{ txHash, proofCode }`.
> 5. Save the full proof record using `proofService`.
> 6. Return to frontend:
>
>    * `proofCode`
>    * `txHash`
>    * `shareUrl` (e.g. `https://<app-domain>/p/<proofCode>`)
>
> Frontend should show a success screen with:
>
> * Proof code
> * Shareable link
> * Copy-to-clipboard buttons.
>
> ---
>
> ### 2. â€œView / Verify CVâ€ (Recruiter)
>
> Routes:
>
> * `/p/:proofCode` â€“ public proof page
> * `/api/proof/:proofCode` â€“ backend API
>
> Backend `GET /api/proof/:proofCode`:
>
> * Look up proof record in `proofService`.
> * If not found, return 404.
> * If found, return:
>
>   * `ownerAddress`
>   * `sealObjectId`
>   * `walrusContentId`
>   * `storageUrl`
>   * `ciphertextHash`
>   * `txHash`
>   * `createdAt`
>
> Frontend on `/p/:proofCode`:
>
> 1. Fetch metadata from `/api/proof/:proofCode`.
> 2. For MVP, mock a **â€œConnect Walletâ€** step with a fake `recruiterAddress` or a simple text input.
> 3. Call backend `GET /api/proof/:proofCode/decrypted` (you should implement this).
>
> Backend `GET /api/proof/:proofCode/decrypted`:
>
> 1. Get proof record.
> 2. Call `walrusService.fetchEncryptedCV(walrusContentId)` â†’ `ciphertext`.
> 3. Call `sealService.getDecryptionKey({ sealObjectId, viewerAddress })` â†’ `decryptKey` (mock logic for now, always allow).
> 4. Call `sealService.decryptCV({ ciphertext, decryptKey })` â†’ `pdfBytes`.
> 5. Return the PDF bytes as a file download or as a base64 string.
>
> Frontend:
>
> * Show a **â€œView CVâ€** button that either:
>
>   * opens the PDF in a new tab, or
>   * renders it inline using an `<iframe>` / `object` tag.
> * Also display:
>
>   * status badge: â€œProof verified (mocked on-chain)â€
>   * owner wallet
>   * timestamp
>   * tx hash / proof code.
>
> ---
>
> ## UI / UX Requirements
>
> * Clean, professional HR-style UI:
>
>   * Header: logo + â€œRegister CVâ€ + â€œVerifyâ€
>   * Hero section on `/` with:
>
>     * Title: â€œTamper-Proof CV Verificationâ€
>     * Subtitle explaining on-chain proof
>     * Two buttons: â€œRegister CVâ€ and â€œVerify CVâ€
> * Proof page should show:
>
>   * A clear verification status
>   * Proof metadata
>   * â€œView CVâ€ button linked to decrypted PDF.
>
> ---
>
> ## What I Want from You (Replit)
>
> * Scaffold the full project (client + server) in a single Replit.
> * Implement the `Register CV` and `View / Verify CV` flows end-to-end using **mocked Seal / Walrus / Sui services**, with all logic placed in `sealService`, `walrusService`, `suiService`, and `proofService` modules.
> * Add clear code comments indicating where real SDK calls for Seal, Walrus, and Sui should be plugged in later.
> * Make the app runnable with a single â€œRunâ€ command.
>
> Start by setting up the project structure and the service modules, then implement the backend routes and frontend pages step by step.

